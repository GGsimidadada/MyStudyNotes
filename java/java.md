### 基础

1. 一个java文件可以对应多个类，但是至多有一个public类、
2. 正确编译后的源文件，会得到相应的字节码文件，编译器位每个类生成独立的字节码文件，且将字节码文件自动命名位类的名字且以`.class`为扩展名。
3. `main`方法是Java应用程序的入口方法，它有固定的书写格式：`puclic static void main(String args){ ... }`。



### 数据类型

整型变量：以0开头是八进制，以0x开头是十六进制，以0b开头是二进制。

整型常量默认是`int`类型，后面加`L`表示这是一个`long`类型的常量。



浮点型可分为`float`和`double`类型。`float`占用4个字节，`double`占用8个字节。

`float`类型又被称作单精度类型，尾数可以精确到7位有效数。而`double`类型又被称作双精度类型。

由于java中浮点常量默认为`double`类型，所以`float`类型的小数后面要加`F`。

浮点数不精确，尽量不要用于比较。如果想要比较，可以使用java下面的两个包`BigInteger`和`BigDecimal`。



字符型在内存中占2个字节。`char`表示字符类型，占一个字符，用`''`单引号来表示。如果用`""`双引号则表示字符串，用`String`类型定义，表示字符序列。



布尔类型`boolean`有两个常量值，`true`和`false`，在内存中占一位（不是一个字节）。



### 运算符

二元运算符：

整数运算：如果两个操作数有一个为Long，结果为Long类型，否则为int类型。

浮点运算：如果两个操作数有一个为double类型，结果为double类型。只有当两个数都为float类型时，结果才为float类型。



逻辑运算符：

`^`代表异或，表示为两个值相同返回`false`，不同则返回`false`。



位运算符：

左移运算符`<<`，左移一位相当于*2

右移运算符`>>`，右移一位相当于/2



### 自动类型转换

自动类型转换指的是容量小的数据类型可以自动转换为容量大的数据类型。



### 强制类型转换

在变量前使用`(类型)`的形式。可能会造成精度丢失。



### 方法

方法声明格式：

```java
[修饰符1 修饰符2 ...] 返回值类型 方法名 (形参列表) {
    Java语句...
}
```

没有返回值的话，必须显式指定为`void`。

普通方法需要通过对象来调用。

方法的重载：实际是完全不同的方法，只是名称相同而已。

构成方法重载的条件：形参的类型、形参的个数、形参的顺序不同，而方法名相同。



### 类

一个java文件可以有多个类，但是只能有一个public修饰的类。

不能在构造器中返回值。



### Super

子类继承父类，创建子类实例时，会先调用父类构造函数，再调用子类构造函数。

默认会调用父类无参数的构造函数，如果想调用定义的含有参数的构造函数，则需要用`super`关键字显式调用。



### static 关键字

static修饰的成员变量和方法，从属于类，普通方法和变量从属于实例对象。

实例方法可以访问静态属性和静态方法，但是静态方法中不能访问实例方法和实例属性。



### 静态初始化块

```java
public class User {
	static {
		System.out.println("这里写静态初始化块的代码");
	}
}
```





### Object类

`Object`类是所有类的父类，使用`class`创建类时会自动`extends Object`。

 `Object`提供一个`toString()`方法，会返回当前对象的字符串表达。

当对象没有一个引用指向它的时候，会被垃圾回收机制回收，触发它的`finalize()`方法。

`equals()`方法，用于比较两个对象内容是否相等。



### Final关键字

`final`修饰类时，表示类不能被继承，子类会出现编译错误。

`final`修饰方法时，表示方法不能被重写，包括对象方法和静态方法。

`final`不能修饰构造方法。

`final`修饰基本变量时，一旦此变量被赋值，则不能再次被重新赋值了。

`final`修饰引用变量时，一旦变量指向了一个对象，则不能重新指向对象了。但是依然可以修改当前对象的属性。

`final`可以用于定义常量，常量指的是可以公开，直接访问，但是不能被更改的值。



### 抽象类

抽象类的意义在于为子类提供统一的规范的模板，子类必须实现相关的抽象方法。

通过`abstract`声明的类为抽象类，通过`abstract`声明的方法为抽象方法。

抽象类可以没有抽象方法，但是抽象方法必须在抽象类内。

不能直接实例化抽象类，即不能通过`new`关键字来创建实例。

抽象类可以包婚属性、方法、构造方法，但是构造方法不能用来new实例，只能用来被子类调用。

抽象类只能用来被继承。

抽象类的子类必须实现抽象方法。

子类只能继承一个抽象类，但是可以继承多个接口。

抽象类可以定义：`public` `protected` `package` `private` `static` `final` 属性。

接口中的属性只能是：`public` `static` `final`的。



### 内部类

可以直接在类里面定义一个类。分为非静态内部类、静态内部类、匿名类、本地类。

#### 非静态内部类

创建非静态内部类时，必须先创建外部类，再创s建内部类。

```java
new 外部类().new 内部类();
```

非静态内部类，可以直接访问外部类的私有实例属性和私有静态属性。

#### 静态内部类

创建静态内部类时，无需实例化外部类，可以直接通过外部类来创建内部类。

```java
new 外部类.内部类();
```

静态内部类，可以直接访问外部私有静态属性，但是不能访问私有实例属性。



### 接口

接口内不提供任何实现。可以更加规范的对子类进行约束，全面的专业和的实现了规范和具体实现的分离。

声明格式：

```java
[ 访问修饰符 ] interface 接口名 [ extends 父接口1, 父接口2, ... ] {
    常量定义：
    方法定义：
}
```

定义接口的说明：

1. 访问修饰符只能是public或者默认
2. 接口名和类名采用相同命名机制。
3. extends：接口可以多继承
4. 常量：接口中的属性只能是常量，总是：public static final 修饰。
5. 方法：接口中的方法只能是：public abstract。